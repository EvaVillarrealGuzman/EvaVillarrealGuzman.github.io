---
layout: post
title: UID/GID in Docker 
subtitle: Understanding how uid and gid work in Docker containers and how this can generate a permissions error in the development stage
categories: docker
tags: [docker]
--- 

When you are using Docker in development environment and you use some tool that generates files during development, such as  dependecies managment (e.g. npm, composer) or to compile task (e.g. SCSS to CSS), if you try to delete or modify these files generated by the tool, maybe you will find with permission denied.

We'll try to undertand why this happens and how you can fix it.

## The problem

Let's start with a container that uses composer to manage the project's dependencies:

```bash
docker container run --rm \
    -v ${PWD}:/var/www \
    -w /var/www \
    composer:2.2 composer require psr/log
```

If you list the folder, you can see that the user who owns the folders/files generated by composer is root:

```bash
$ ls -la
total 20K
drwxrwxr-x. 3 eva       eva       4.0K mar  27 18:31 ./
drwxr-xr-x. 7 eva       eva       4.0K mar  27 18:29 ../
drwxr-xr-x. 4 root      root      4.0K mar  27 18:31 vendor/
-rw-r--r--. 1 root      root        53 mar  27 18:31 composer.json
-rw-r--r--. 1 root      root      2.1K mar  27 18:31 composer.lock
```

So if you try to remove/modify it, you'll get a permissions error:

```bash
$ echo '' > composer.json 
bash: composer.json: Permission denied
```

To undertand why this happens, you need to undertand how Linux map the uid (user identifier) and the gid (group identifier).

The Linux kernel is responsible for managing the uid and gid space, and it is the kernel-level syscalls that are used to determine whether the requested privileges should be granted. For example, when a process attempts to write to a file, the kernel examines the uid and gid that created the process to determine if it has sufficient privileges to modify the file. **The important to grant or not privileges is the uid, not the username**.

When we run docker containers, there’s still uses the same kernel as the host. That is, all the processes running inside the containers share the same kernel of the host kernel. This kernel, as we said before, manages all uid and gid.

So you can't have different users with the same uid inside different containers. So why can I define different usernames (and group names) between containers that have the same uid (and gid)? This is because **username (and group names) that appear in common Linux tools are not part of the kernel, but are managed by external tools** (/etc/passwd, LDAP, Kerberos , etc.). So you might see different usernames, since both host and containers have their own separate list of users and groups in /etc/passwd and /etc/group respectively, but you can't have different privileges to the same uid/gid.

Now, why are the folders/files generated by composer owned by root?

The reason this happens is that Docker runs on Linux as root, if you follow the recommendations of the official installation. So when you create a new container, it's not created by the current user, but by the root user which is the daemon running underneath. This is important to consider in order to build a secure system, **if no other option is provided, such as passing a different uid in the Dockerfile, the processes in the containers will run as root**.

You can verify this as follows:

```bash
$ docker container run --rm \
    -v ${PWD}:/var/www \
    -w /var/www \
    composer:2.2 whoami
root
```

As you can see, the result of ```whoami``` (which returns the current user) in the container is root. If you run the following command:

```bash
$ docker container run --rm \
    -v ${PWD}:/var/www \
    -w /var/www \
    composer:2.2 \
        bash -c "echo \$(id -u \${USER}):\$(id -g \${USER})"
0:0
```

You'll see that the id of the user and group inside the container is 0.

> It is important to remember that in Linux the root user/group has an id, by convention, which is 0.

## Solution 1

You can run the Docker container as your local user, passing the uid and gid. You can try this as follows:

```bash
docker container run --rm \
    -v ${PWD}:/var/www \
    -w /var/www \
    -u $(id -u ${USER}):$(id -g ${USER}) \
    composer:2.2 composer require psr/log
```

If you list the folder, you can see that the user who owns the folders/files generated by composer is the local user:

```bash
$ ls -la
total 20K
drwxrwxr-x. 3 eva eva 4.0K mar  27 19:04 ./
drwxr-xr-x. 7 eva eva 4.0K mar  27 18:29 ../
drwxr-xr-x. 4 eva eva 4.0K mar  27 19:04 vendor/
-rw-r--r--. 1 eva eva   53 mar  27 19:04 composer.json
-rw-r--r--. 1 eva eva 2.1K mar  27 19:04 composer.lock
```

Depending on the project being considered, this solution may have a problem. Inside the container, the user is not longer root. If the application inside the container requires perform tasks as root, you'll get permissions error inside the container. For example, if you want to run a web application with PHP-FPM:

```bash
$ docker container run --rm \
    -v ${PWD}:/var/www \
    -w /var/www \
    -u $(id -u ${USER}):$(id -g ${USER}) \
    composer:2.2 touch /var/lib/php/sessions/foo
touch: cannot touch '/var/lib/php/sessions/foo': Permission denied
```

This is because the folder ```/var/lib/php/sessions``` is owned by ```www-data:www-data```, which most likely does not share your local user’s IDs:

```bash
$ docker container run --rm \
    -v ${PWD}:/var/www \
    -w /var/www \
    composer:2.2 \
        bash -c "echo \$(id -u www-data):\$(id -g www-data)"
33:33
```

## Solution 2

You can replace the internal user/group IDs with known, good values. In this way, you can change the uid/guid of www-data in the container, passing it the uid/guid of the local user.

To do this, you must first create the Dockerfile file to perform this task:

``` 
FROM composer:2.2

ARG USER_ID
ARG GROUP_ID

RUN if [ ${USER_ID:-0} -ne 0 ] && [ ${GROUP_ID:-0} -ne 0 ]; then \
    userdel -f www-data &&\
    if getent group www-data ; then groupdel www-data; fi &&\
    groupadd -g ${GROUP_ID} www-data &&\
    useradd -l -u ${USER_ID} -g www-data www-data &&\
    install -d -m 0755 -o www-data -g www-data /home/www-data &&\
    chown --changes --silent --no-dereference --recursive \
          --from=33:33 ${USER_ID}:${GROUP_ID} \
        /home/www-data \
        /.composer \
        /var/run/php-fpm \
        /var/lib/php/sessions \
;fi
        
USER www-data
```

Basically what you do in this Dockerfile is pass the id of our current user/group on the host as an environment variable in the container. In the ```if [ ${USER_ID:-0} -ne 0 ] && [ ${GROUP_ID:-0} -ne 0 ]; then``` line, you allow the USER_ID and GROUP_ID variables to be optional. If both are not defined, the process that follows is skipped. This makes the Dockerfile usable for both development and production purposes.

In case the variables are defined, the user and group www-data are eliminated:

``` 
    userdel -f www-data &&\
    if getent group www-data ; then groupdel www-data; fi &&\
```

Then, the user/group are recreated with the default values:

``` 
    useradd -l -u ${USER_ID} -g www-data www-data &&\
```

Also, a folder for the user www-data is generated. This is useful if you need your container to perform SSH actions using your host's SSH keys.

``` 
    install -d -m 0755 -o www-data -g www-data /home/www-data &&\
```

In the next line, change the owner to folders that may require updating. In this way, permission error are avoided. To know which are the folders that need to be updated, you can look at the Dockerfile of the image.

``` 
    chown --changes --silent --no-dereference --recursive \
          --from=33:33 ${USER_ID}:${GROUP_ID} \
        /home/www-data \
        /.composer \
        /var/run/php-fpm \
        /var/lib/php/sessions \
```

Now, build the image:

```bash 
$ docker image build \
    --build-arg USER_ID=$(id -u ${USER}) \
    --build-arg GROUP_ID=$(id -g ${USER}) \
    -t php_test \
    .
```

Run composer:

```bash 
$ docker container run --rm \
    -v ${PWD}:/var/www \
    -w /var/www \
    php_test:latest composer require psr/log
```

And if you list the folder, you can see as follows:

```bash
$ ls -lan
total 24K
drwxrwxr-x. 3 1000 1000 4.0K mar  27 19:24 ./
drwxr-xr-x. 7 1000 1000 4.0K mar  27 18:29 ../
drwxr-xr-x. 4 1000 1000 4.0K mar  27 19:24 vendor/
-rw-rw-r--. 1 1000 1000  545 mar  27 19:19 Dockerfile
-rw-r--r--. 1 1000 1000   53 mar  27 19:24 composer.json
-rw-r--r--. 1 1000 1000 2.1K mar  27 19:24 composer.lock
```

The vendor folder generated by composer is owned by the local user's uid/gid. Inside the container, www-data has this uid/gid. Now you can delete/update without permissions error.

### Use Docker Compose

The equivalent docker-compose.yml for this example would be:

```yml
# docker-compose.yml
version: '3.2'
services:
  php:
    build:
      context: .
      dockerfile: Dockerfile
      args:
        USER_ID: ${USER_ID:-0}
        GROUP_ID: ${GROUP_ID:-0}
    volumes:
      - ${HOME}/.composer:/.composer
      - ${PWD}:/var/www
```

The user/group id must be defined in an .env file as below. Docker compose cannot parse commands, so ```$(id -u ${USER})``` would not work in the yaml file.

```
USER_ID=1000
GROUP_ID=1000
```

To build the image and run the container, run as follows:

```
docker-compose up -d --build
```

## Sources

- [Running Docker Containers as Current Host User](https://jtreminio.com/blog/running-docker-containers-as-current-host-user/#ok-so-what-actually-works/)
- [Esto no me lo imaginaba - UID y GIDs en Docker](https://www.youtube.com/watch?v=0xUwaz0MD_E)
- [Understanding how uid and gid work in Docker containers](https://medium.com/@mccode/understanding-how-uid-and-gid-work-in-docker-containers-c37a01d01cf)

