<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  <meta name="generator" content="Jekyll">

  <title>Caché en Yii2</title>

  <link rel="stylesheet" href="/css/main.css">
  
  <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed" /> <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Caché en Yii2 | Blog</title>
<meta name="generator" content="Jekyll v4.2.1" />
<meta property="og:title" content="Caché en Yii2" />
<meta name="author" content="Eva Villarreal Guzmán" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Para entender porque necesitamos implementar caché en nuestras web, entendamos primero que pasa cuando interactuamos con un servidor web." />
<meta property="og:description" content="Para entender porque necesitamos implementar caché en nuestras web, entendamos primero que pasa cuando interactuamos con un servidor web." />
<link rel="canonical" href="http://localhost:8002/YII2-Caching" />
<meta property="og:url" content="http://localhost:8002/YII2-Caching" />
<meta property="og:site_name" content="Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-01-05T00:00:00-03:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Caché en Yii2" />
<script type="application/ld+json">
{"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:8002/YII2-Caching"},"@type":"BlogPosting","url":"http://localhost:8002/YII2-Caching","author":{"@type":"Person","name":"Eva Villarreal Guzmán"},"headline":"Caché en Yii2","dateModified":"2022-01-05T00:00:00-03:00","datePublished":"2022-01-05T00:00:00-03:00","description":"Para entender porque necesitamos implementar caché en nuestras web, entendamos primero que pasa cuando interactuamos con un servidor web.","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

</head>

<body>
  <div id="wrapper">
    <header>
  <div>
    <a href="/">
    
    <h1>Eva Villarreal Guzmán</h1>
    </a>
    <div class="header-links">
      <a href="/archive"><h2 class="header-link">Archive</h2></a>
<a href="/about"><h2 class="header-link">About</h2></a>
<a href="/atom.xml"><h2 class="header-link">RSS</h2></a>
    </div>
  </div>
</header>
    <div class="container">
      <section id="main_content">
        <article>
  <h2>Caché en Yii2</h2>
  <time datetime="2022-01-05T00:00:00-03:00" class="by-line">05 Jan 2022</time>
  <p>Para entender porque necesitamos implementar caché en nuestras web, entendamos primero que pasa cuando interactuamos con un servidor web.</p>

<p>Cada vez que se realiza una <em>request</em> a una aplicación web suceden un conjunto de cosas en tu servidor, por ejemplo:</p>

<ul>
  <li>Probablemente se conectará a una o varias bases de datos.</li>
  <li>También puede que se accedan a archivos locales o se realicen cálculos matemáticos, generando una carga en la CPU.</li>
</ul>

<p>Es decir, cada <em>request</em> tiene una cierta cantidad de demanda de CPU y disco de red y, en algunas aplicaciones especializadas, incluso puede haber otras cosas involucradas.</p>

<p>Todas esas cosas son las que afectan el tiempo que pasa entre que las <em>requests</em> llegan al servidor web y éste pueda generar la respuesta y ser enviada al usuario. Por lo tanto cuanto más disco o CPU se use y cuanto más se acceda a una base de datos, más lenta será la respuesta de su servidor.</p>

<p>Si se realiza otra <em>request</em> para ese mismo contenido, en la mayoría de los casos ocurrirá exactamente lo mismo y su servidor tendrá que manejar ese acceso al disco en esa red y esa sobrecarga de CPU requerida para la <em>request</em> por segunda o tercera vez o varias veces. ¿Qué ocurre cuando algunos de estos recursos comienza a acercarse a su límite? Se empezará a ralentizar o provocará un error. Por lo tanto, si la CPU alcanza los límites de su servidor, si el acceso al disco es tan lento que las cosas comienzan a agotarse o si la carga de su base de datos es tan pesada que nuevamente obtiene un error de <em>time out</em> o incluso el servidor web podría agotar el <em>time out</em> esperando la base de datos responder.</p>

<p>La forma más fácil de reducir el uso de estos recursos es almacenar en caché los datos cuando se generan en la memoria. De esta manera el objetivo es que se pueden atender la mayor cantidad de <em>requests</em> posibles directamente desde la memoria, minimizando el uso de CPU o disco de red y el acceso a la base de datos.</p>

<p>Esto tendrá algunos costos:</p>
<ul>
  <li>Su código será un poco más complejo, no demasiado, pero tendrá que escribir un código adicional.</li>
  <li>Requerirá memoria adicional y eso podría tener un efecto en el tipo de servidor que puede usar para su servidor. Dependiendo de qué es exactamente lo que vas a almacenar en caché, es posible que no requieras mucha memoria.</li>
</ul>

<p>Si está diseñando un servicio web para que miles de usuarios seguramente la caché será uno de los mecanismo que utilice. Ya que cuantas más <em>requests</em> pueda manejar con los mismos recursos, menos servidores necesitará, lo cual es más barato y también podría significar que puede usar una sola base de datos para su aplicación en lugar de múltiples bases de datos.</p>

<p>Ahora yendo particularmente a Yii2, el <em>caching</em> es una de las características que el <em>framework</em> provee. Veamos los diferentes mecanismos de almacenamiento en caché y como configurarlos.</p>

<h2 id="claves-de-caché"><a href="#header-2"></a>Claves de Caché</h2>

<p>Es importante tener en cuenta que cada elemento de datos almacenado en caché se identifica por una <strong>clave</strong>. Cuando se almacena un elemento de datos en la memoria caché, se debe especificar una clave. Más tarde, cuando se recupera el elemento de datos de la memoria caché, se debe proporcionar la clave correspondiente.</p>

<p>Puedes utilizar una cadena o un valor arbitrario como una clave de caché. Cuando una clave no es una cadena de texto, ésta será automáticamente serializada en una cadena.</p>

<p>Una estrategia común para definir una clave de caché es incluir en ella todos los factores determinantes en términos de un array. Por ejemplo, <code class="language-plaintext highlighter-rouge">yii\db\Schema</code> utiliza la siguiente clave para almacenar en caché la información del esquema de una tabla de base de datos:</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span>
    <span class="k">__CLASS__</span><span class="p">,</span>              <span class="c1">// nombre de la clase del esquema</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="n">db</span><span class="o">-&gt;</span><span class="n">dsn</span><span class="p">,</span>         <span class="c1">// nombre del origen de datos de la conexión BD</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="n">db</span><span class="o">-&gt;</span><span class="n">username</span><span class="p">,</span>    <span class="c1">// usuario para la conexión BD</span>
    <span class="nv">$name</span><span class="p">,</span>                  <span class="c1">// nombre de la tabla</span>
<span class="p">];</span>
</code></pre></div></div>
<p>Como puedes ver, la clave incluye toda la información necesaria para especificar de una forma exclusiva una tabla de base de datos.</p>

<p>Cuando en un mismo almacenamiento en caché es utilizado por diferentes aplicaciones, se debería especificar un prefijo único para las claves de la caché por cada una de las aplicaciones para así evitar conflictos.Por ejemplo, en la configuración de la aplicación podrías escribir el siguiente código:</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s1">'components'</span> <span class="o">=&gt;</span> <span class="p">[</span>
    <span class="s1">'cache'</span> <span class="o">=&gt;</span> <span class="p">[</span>
        <span class="s1">'class'</span> <span class="o">=&gt;</span> <span class="s1">'yii\caching\ApcCache'</span><span class="p">,</span>
        <span class="s1">'keyPrefix'</span> <span class="o">=&gt;</span> <span class="s1">'myapp'</span><span class="p">,</span>       <span class="c1">// un prefijo de clave de caché único</span>
    <span class="p">],</span>
<span class="p">],</span>
</code></pre></div></div>

<h2 id="formas-de-invalidar-un-elemento-de-caché"><a href="#header-2"></a>Formas de invalidar un elemento de caché</h2>

<p>Un elemento de datos almacenado en la memoria caché permanecerá en ella para siempre, a menos que sea removida de alguna manera debido a alguna directiva de caché (ej. el espacio de almacenamiento en caché está lleno y los datos más antiguos se eliminan). Para cambiar este comportamiento Yii provee diferentes mecanismos que se envían por parámetro al guardar el elemento de dato para invalidar un elemento de caché:</p>

<h3 id="caducidad-de-caché"><a href="#header-3"></a>Caducidad de Caché</h3>

<p>El parámetro nos indica por cuántos segundos el elemento se mantendrá válido en memoria caché. Cuando llames get() para recuperar el elemento, si el tiempo de caducidad ha pasado, el método devolverá <code class="language-plaintext highlighter-rouge">false</code>, indicando que el elemento de datos no ha sido encontrado en la memoria caché.</p>

<h3 id="dependencias"><a href="#header-3"></a>Dependencias</h3>

<p>Los datos almacenados en caché pueden también ser invalidados conforme a algunos cambios en la caché de dependencias, donde las disponibles son:</p>

<ul>
  <li>yii\caching\ChainedDependency: la dependencia cambia si cualquiera de las dependencias en la cadena cambia.</li>
  <li>yii\caching\DbDependency: la dependencia cambia si el resultado de la consulta de la sentencia SQL especificada cambia.</li>
  <li>yii\caching\ExpressionDependency: la dependencia cambia si el resultado de la expresión de PHP especificada cambia.</li>
  <li>yii\caching\FileDependency: la dependencia cambia si se modifica la última fecha de modificación del archivo.</li>
  <li>yii\caching\TagDependency: marca un elemento de datos en caché con uno o más <em>tags</em>. Cada <em>tag</em> puede ser invalidado llamando a yii\caching\TagDependency::invalidate(), de manera que invalidaría a todos los elementos de datos que contienen dicho <em>tag</em>.</li>
</ul>

<h2 id="mecanismos-de-caché"><a href="#header-2"></a>Mecanismos de caché</h2>

<h3 id="caché-de-datos"><a href="#header-3"></a>Caché de datos</h3>

<p>Es el mecanismo más básico y suele ser la base de los demás mecanismos. Trata del almacenamiento de alguna variable PHP en caché y recuperarla más tarde.</p>

<p>El siguiente código muestra el patrón típico de uso para el almacenamiento en caché:</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// intenta recuperar $data de la caché</span>
<span class="nv">$data</span> <span class="o">=</span> <span class="nv">$cache</span><span class="o">-&gt;</span><span class="nf">get</span><span class="p">(</span><span class="nv">$key</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="nv">$data</span> <span class="o">===</span> <span class="kc">false</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// $data no ha sido encontrada en la caché, calcularla desde cero</span>
    <span class="nv">$data</span> <span class="o">=</span> <span class="nc">Products</span><span class="o">::</span><span class="nf">findOne</span><span class="p">(</span><span class="nv">$id</span><span class="p">);</span>
    <span class="c1">// guardar $data en caché para así recuperarla la próxima vez</span>
    <span class="nv">$cache</span><span class="o">-&gt;</span><span class="nf">set</span><span class="p">(</span><span class="nv">$key</span><span class="p">,</span> <span class="nv">$data</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// $data está disponible aquí</span>
</code></pre></div></div>

<p>El siguiente código se puede escribir también como:</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$data</span> <span class="o">=</span> <span class="nv">$cache</span><span class="o">-&gt;</span><span class="nf">getOrSet</span><span class="p">(</span><span class="nv">$key</span><span class="p">,</span> <span class="k">function</span> <span class="p">()</span> <span class="k">use</span> <span class="p">(</span><span class="nv">$id</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nc">Products</span><span class="o">::</span><span class="nf">findOne</span><span class="p">(</span><span class="nv">$id</span><span class="p">);</span>
    <span class="p">});</span>
</code></pre></div></div>

<h3 id="caché-de-consultas"><a href="#header-3"></a>Caché de consultas</h3>

<p>La caché de consultas es una característica especial de caché construido sobre el almacenamiento de caché de datos. Se proporciona para almacenar en caché el resultado de consultas a la base de datos.</p>

<p>Las consultas en caché requieren una <code class="language-plaintext highlighter-rouge">DB connection</code> y un componente de aplicación caché válido. Las implementaciones de caché de consultas podemos verlos en los siguientes códigos para los diferentes casos:</p>

<h4 id="caché-de-raw-query"><a href="#header-4"></a>Caché de <em>raw query</em></h4>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$db</span> <span class="o">=</span> <span class="nc">Client</span><span class="o">::</span><span class="nf">getDb</span><span class="p">();</span>
<span class="nv">$result</span> <span class="o">=</span> <span class="nv">$db</span><span class="o">-&gt;</span><span class="nf">cache</span><span class="p">(</span><span class="k">function</span> <span class="p">(</span><span class="nv">$db</span><span class="p">)</span> <span class="k">use</span> <span class="p">(</span><span class="nv">$id</span><span class="p">)</span> <span class="p">{</span>
    <span class="nv">$query</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Yii\db\Query</span><span class="p">;</span>
    <span class="nv">$query</span><span class="o">-&gt;</span><span class="nf">select</span><span class="p">(</span><span class="s2">"client.*"</span><span class="p">)</span>
        <span class="o">-&gt;</span><span class="nf">from</span><span class="p">(</span><span class="s1">'client'</span><span class="p">)</span>
        <span class="o">-&gt;</span><span class="nf">where</span><span class="p">([</span><span class="s1">'client.id'</span> <span class="o">=&gt;</span> <span class="nv">$id</span><span class="p">])</span>
        <span class="o">-&gt;</span><span class="nf">one</span><span class="p">();</span>
    <span class="nv">$command</span> <span class="o">=</span> <span class="nv">$query</span><span class="o">-&gt;</span><span class="nf">createCommand</span><span class="p">();</span>
    <span class="nv">$result</span>  <span class="o">=</span> <span class="nv">$command</span><span class="o">-&gt;</span><span class="nf">queryAll</span><span class="p">();</span>
    <span class="k">return</span> <span class="nv">$result</span><span class="p">;</span>
<span class="p">});</span>
</code></pre></div></div>

<h4 id="caché-de-activerecord"><a href="#header-4"></a>Caché de ActiveRecord</h4>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$result</span> <span class="o">=</span> 
<span class="nv">$db</span> <span class="o">=</span> <span class="nc">Yii</span><span class="o">::</span><span class="nv">$app</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">;</span><span class="c1">// or Category::getDb()</span>
<span class="nv">$dep</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DbDependency</span><span class="p">();</span>
<span class="nv">$dep</span><span class="o">-&gt;</span><span class="n">sql</span> <span class="o">=</span> <span class="s1">'SELECT count(*) FROM category'</span><span class="p">;</span>
<span class="nv">$result</span> <span class="o">=</span> <span class="nv">$db</span><span class="o">-&gt;</span><span class="nf">cache</span><span class="p">(</span><span class="k">function</span> <span class="p">(</span><span class="nv">$db</span><span class="p">)</span> <span class="k">use</span> <span class="p">(</span><span class="nv">$id</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nc">Category</span><span class="o">::</span><span class="nf">find</span><span class="p">()</span><span class="o">-&gt;</span><span class="nf">where</span><span class="p">([</span><span class="s1">'id'</span> <span class="o">=&gt;</span> <span class="nv">$id</span><span class="p">])</span><span class="o">-&gt;</span><span class="nf">all</span><span class="p">();</span>
<span class="p">},</span> <span class="no">CACHE_TIMEOUT</span><span class="p">,</span> <span class="nv">$dep</span><span class="p">);</span>
</code></pre></div></div>

<h5 id="caché-en-activequery--all-y--one"><a href="#header-5"></a>Caché en ActiveQuery -&gt;all() y -&gt;one()</h5>

<p>Puede habilitar fácilmente el almacenamiento en caché de todas las consultas para una tabla determinada siguiendo el ejemplo siguiente. Digamos que tenemos una tabla de <strong>clientes</strong> y deseamos almacenar en caché los datos del cliente durante 10 minutos (600 segundos). Primero agregue un archivo <strong>ClientQuery.php</strong> en el mismo directorio que su modelo <strong>Client.php</strong> y configure <code class="language-plaintext highlighter-rouge">$queryCacheDuration</code> en segundos:</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?php</span>

<span class="kn">namespace</span> <span class="nn">app\models\application</span><span class="p">;</span>

<span class="cd">/**
 * This is the ActiveQuery class for [[Client]].
 *
 * @see Client
 */</span>
<span class="kd">class</span> <span class="nc">ClientQuery</span> <span class="kd">extends</span> <span class="nc">Yii\db\ActiveQuery</span>
<span class="p">{</span>
	<span class="k">public</span> <span class="nv">$queryCacheDuration</span> <span class="o">=</span> <span class="mi">600</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Luego agrega un método find() en tu modelo para que haga referencia a <strong>ClientQuery</strong>:</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/**
 * @inheritdoc
 * @return ClientQuery the active query used by this AR class.
 */</span>
<span class="k">public</span> <span class="k">static</span> <span class="k">function</span> <span class="n">find</span><span class="p">()</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="k">new</span> <span class="nc">ClientQuery</span><span class="p">(</span><span class="nb">get_called_class</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Alternativamente, puede anular las rutinas all () y one () y configurar el uso de la caché allí (nuevamente, en su archivo <strong>ClientQuery.php</strong>):</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?php</span>

<span class="kn">namespace</span> <span class="nn">app\models\application</span><span class="p">;</span>

<span class="cd">/**
 * This is the ActiveQuery class for [[Client]].
 *
 * @see Client
 */</span>
<span class="kd">class</span> <span class="nc">ClientQuery</span> <span class="kd">extends</span> <span class="nc">Yii\db\ActiveQuery</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">function</span> <span class="n">all</span><span class="p">(</span><span class="nv">$db</span> <span class="o">=</span> <span class="kc">null</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="nf">cache</span><span class="p">(</span><span class="mi">60</span><span class="p">);</span>
        <span class="k">return</span> <span class="k">parent</span><span class="o">::</span><span class="nf">all</span><span class="p">(</span><span class="nv">$db</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">function</span> <span class="n">one</span><span class="p">(</span><span class="nv">$db</span> <span class="o">=</span> <span class="kc">null</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="nf">cache</span><span class="p">(</span><span class="mi">60</span><span class="p">);</span>
        <span class="k">return</span> <span class="k">parent</span><span class="o">::</span><span class="nf">one</span><span class="p">(</span><span class="nv">$db</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h5 id="caché-de-una-consulta-basada-en-relaciones"><a href="#header-5"></a>Caché de una consulta basada en relaciones</h5>

<p>La acción en el controlador (sin caché) es:</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$model</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="nf">findModel</span><span class="p">(</span><span class="nv">$id</span><span class="p">);</span>
<span class="nv">$issues</span> <span class="o">=</span> <span class="nv">$model</span><span class="o">-&gt;</span><span class="nf">getCurrentIssues</span><span class="p">()</span>
    <span class="o">-&gt;</span><span class="nf">orderBy</span><span class="p">(</span><span class="s1">'ID DESC'</span><span class="p">)</span>
    <span class="o">-&gt;</span><span class="nf">all</span><span class="p">();</span>
<span class="nv">$retVal</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="nf">renderAjax</span><span class="p">(</span><span class="s1">'issues/issues'</span><span class="p">,</span> <span class="p">[</span>
    <span class="s1">'model'</span> <span class="o">=&gt;</span> <span class="nv">$model</span><span class="p">,</span>
    <span class="s1">'issues'</span> <span class="o">=&gt;</span> <span class="nv">$issues</span>
</code></pre></div></div>

<p>Donde $model-&gt;getCurrentIssues() es una relación en el modelo:</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">function</span> <span class="n">getCurrentIssues</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="nf">hasMany</span><span class="p">(</span><span class="nc">Issue</span><span class="o">::</span><span class="n">class</span><span class="p">,</span> <span class="p">[</span><span class="s1">'SiteID'</span> <span class="o">=&gt;</span> <span class="s1">'ID'</span><span class="p">])</span>
            <span class="o">-&gt;</span><span class="nf">onCondition</span><span class="p">([</span><span class="s1">'Deleted'</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="p">])</span>
            <span class="o">-&gt;</span><span class="nf">andOnCondition</span><span class="p">([</span><span class="s1">'in'</span><span class="p">,</span> <span class="s1">'IssueStatusID'</span><span class="p">,</span> <span class="p">(</span><span class="k">new</span> <span class="nc">Yii\db\Query</span><span class="p">())</span><span class="o">-&gt;</span><span class="nf">select</span><span class="p">(</span><span class="s1">'ID'</span><span class="p">)</span><span class="o">-&gt;</span><span class="nf">from</span><span class="p">(</span><span class="s1">'issue_status'</span><span class="p">)</span><span class="o">-&gt;</span><span class="nf">where</span><span class="p">([</span><span class="s1">'Code'</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">'REOPENED'</span><span class="p">,</span> <span class="s1">'CONFIRMED'</span><span class="p">,</span> <span class="s1">'NEW'</span><span class="p">]])]);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Para optimizar la acción en el controlador con caché se debería cambiar de la siguiente forma:</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$db</span> <span class="o">=</span> <span class="nc">Yii</span><span class="o">::</span><span class="nv">$app</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">;</span>
<span class="nv">$model</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="nf">findModel</span><span class="p">(</span><span class="nv">$id</span><span class="p">);</span>
<span class="nv">$issues</span> <span class="o">=</span> <span class="nc">Issue</span><span class="o">::</span><span class="nf">getDb</span><span class="p">()</span><span class="o">-&gt;</span><span class="nf">cache</span><span class="p">(</span><span class="k">function</span> <span class="p">(</span><span class="nv">$db</span><span class="p">)</span> <span class="k">use</span><span class="p">(</span><span class="nv">$model</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nv">$model</span><span class="o">-&gt;</span><span class="nf">getPastIssues</span><span class="p">()</span>
    <span class="o">-&gt;</span><span class="nf">orderBy</span><span class="p">(</span><span class="s1">'ID DESC'</span><span class="p">)</span>
    <span class="o">-&gt;</span><span class="nf">all</span><span class="p">();</span>
<span class="p">},</span> <span class="mi">60</span><span class="p">,</span> <span class="kc">null</span><span class="p">);</span>
</code></pre></div></div>

<p>Acá es importante resaltar que configurar la relación del modelo de la siguiente forma no funciona:</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">function</span> <span class="n">getCurrentIssues</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nc">Yii</span><span class="o">::</span><span class="nv">$app</span><span class="o">-&gt;</span><span class="n">db</span><span class="o">-&gt;</span><span class="nf">cache</span><span class="p">(</span><span class="k">function</span><span class="p">(</span><span class="nv">$db</span><span class="p">)</span> <span class="p">{</span>
         <span class="k">return</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="nf">hasMany</span><span class="p">(</span><span class="nc">Issue</span><span class="o">::</span><span class="n">class</span><span class="p">,</span> <span class="p">[</span><span class="s1">'SiteID'</span> <span class="o">=&gt;</span> <span class="s1">'ID'</span><span class="p">])</span>
            <span class="o">-&gt;</span><span class="nf">onCondition</span><span class="p">([</span><span class="s1">'Deleted'</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="p">])</span>
            <span class="o">-&gt;</span><span class="nf">andOnCondition</span><span class="p">([</span><span class="s1">'in'</span><span class="p">,</span> <span class="s1">'IssueStatusID'</span><span class="p">,</span> <span class="p">(</span><span class="k">new</span> <span class="nc">Yii\db\Query</span><span class="p">())</span><span class="o">-&gt;</span><span class="nf">select</span><span class="p">(</span><span class="s1">'ID'</span><span class="p">)</span><span class="o">-&gt;</span><span class="nf">from</span><span class="p">(</span><span class="s1">'issue_status'</span><span class="p">)</span><span class="o">-&gt;</span><span class="nf">where</span><span class="p">([</span><span class="s1">'Code'</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">'REOPENED'</span><span class="p">,</span> <span class="s1">'CONFIRMED'</span><span class="p">,</span> <span class="s1">'NEW'</span><span class="p">]])]);</span>
    <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Ya que el método cache () es activar y desactivar la caché de consultas cuando se llama el <em>callback</em>. Tenga en cuenta que hasMany() o hasOne() no realizan ninguna consulta a la base de datos, por lo que la caché de esta manera no tiene ningún efecto.</p>

<h4 id="caché-de-search-model"><a href="#header-4"></a>Caché de Search Model</h4>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$db</span><span class="o">-&gt;</span><span class="nf">cache</span><span class="p">(</span><span class="k">function</span> <span class="p">()</span> <span class="k">use</span> <span class="p">(</span><span class="nv">$dataProvider</span><span class="p">)</span> <span class="p">{</span>
    <span class="nv">$dataProvider</span><span class="o">-&gt;</span><span class="nf">prepare</span><span class="p">();</span>  <span class="c1">// lanzar consulta a base de datos</span>
    <span class="c1">// o si desea realizar consultas de base de datos AR, puede hacer lo siguiente:</span>
    <span class="c1">// $customers = Customer::find()-&gt;all();</span>
<span class="p">});</span>

<span class="k">return</span> <span class="nv">$dataProvider</span><span class="p">;</span>
</code></pre></div></div>

<blockquote>
  <p>Nota: Algunas bases de datos, como por ejemplo MySQL, soporta el almacenamiento en caché desde el mismo servidor de la base de datos. Puedes optar por utilizar cualquiera de los mecanismos de memoria caché. El almacenamiento en caché de consultas previamente descrito tiene la ventaja que de que se puede especificar dependencias de caché de una forma flexible y son potencialmente mucho más eficientes.</p>
</blockquote>

<h2 id="caché-de-fragmentos"><a href="#header-2"></a>Caché de Fragmentos</h2>

<p>La Caché de Fragmentos se refiere al almacenamiento en caché de una sección de una página Web.</p>

<p>Para usar la caché de fragmentos, utiliza el siguiente código en tu vista:</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="nf">beginCache</span><span class="p">(</span><span class="nv">$id</span><span class="p">))</span> <span class="p">{</span>

    <span class="c1">// ... generar contenido aquí ...</span>

    <span class="nv">$this</span><span class="o">-&gt;</span><span class="nf">endCache</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Es decir, encierra la lógica de la generación del contenido entre las llamadas beginCache() y endCache(). Si el contenido se encuentra en la memoria caché, beginCache() mostrará el contenido y devolverá <code class="language-plaintext highlighter-rouge">false</code>, saltandose así la lógica de generación del contenido. De lo contrario, el código de generación se ejecutaría y al alcanzar la llamada endCache(), el contenido generado será capturado y almacenado en la memoria caché.</p>

<h3 id="opciones-de-caché"><a href="#header-3"></a>Opciones de Caché</h3>

<h4 id="caducidad"><a href="#header-4"></a>Caducidad</h4>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="nf">beginCache</span><span class="p">(</span><span class="nv">$id</span><span class="p">,</span> <span class="p">[</span><span class="s1">'duration'</span> <span class="o">=&gt;</span> <span class="mi">3600</span><span class="p">]))</span> <span class="p">{</span>

    <span class="c1">// ... generar contenido aquí ...</span>

    <span class="nv">$this</span><span class="o">-&gt;</span><span class="nf">endCache</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="dependencias-1"><a href="#header-4"></a>Dependencias</h4>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$dependency</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">'class'</span> <span class="o">=&gt;</span> <span class="s1">'yii\caching\DbDependency'</span><span class="p">,</span>
    <span class="s1">'sql'</span> <span class="o">=&gt;</span> <span class="s1">'SELECT MAX(updated_at) FROM post'</span><span class="p">,</span>
<span class="p">];</span>

<span class="k">if</span> <span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="nf">beginCache</span><span class="p">(</span><span class="nv">$id</span><span class="p">,</span> <span class="p">[</span><span class="s1">'dependency'</span> <span class="o">=&gt;</span> <span class="nv">$dependency</span><span class="p">]))</span> <span class="p">{</span>

    <span class="c1">// ... generar contenido aquí ...</span>

    <span class="nv">$this</span><span class="o">-&gt;</span><span class="nf">endCache</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="variaciones"><a href="#header-4"></a>Variaciones</h4>

<p>El contenido almacenado en caché puede variar de acuerdo a ciertos parámetros. Por ejemplo, para una aplicación Web que soporte multiples idiomas, la misma pieza del código de la vista puede generar el contenido almacenado en caché en diferentes idiomas. Por lo tanto, es posible que desees hacer variaciones del mismo contenido almacenado en caché de acuerdo con la actual selección del idioma en la aplicación.</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="nf">beginCache</span><span class="p">(</span><span class="nv">$id</span><span class="p">,</span> <span class="p">[</span><span class="s1">'variations'</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="nc">Yii</span><span class="o">::</span><span class="nv">$app</span><span class="o">-&gt;</span><span class="n">language</span><span class="p">]]))</span> <span class="p">{</span>

    <span class="c1">// ... generar código aquí ...</span>

    <span class="nv">$this</span><span class="o">-&gt;</span><span class="nf">endCache</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="alternando-el-almacenamiento-en-caché"><a href="#header-3"></a>Alternando el Almacenamiento en Caché</h3>

<p>Puede que a veces quieras habilitar la caché de fragmentos únicamente cuando ciertas condiciones se cumplan. Por ejemplo, para una página que muestra un formulario, tal vez quieras guardarlo en la caché cuando es inicialmente solicitado (a través de una petición <code class="language-plaintext highlighter-rouge">GET</code>). Cualquier muestra posterior (a través de una petición <code class="language-plaintext highlighter-rouge">POST</code>) del formulario no debería ser almacenada en caché ya que el formulario puede que contenga entradas del usuario. Para hacerlo, podrías configurar la opción de activado (<code class="language-plaintext highlighter-rouge">enabled</code>), de la siguiente manera:</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="nf">beginCache</span><span class="p">(</span><span class="nv">$id</span><span class="p">,</span> <span class="p">[</span><span class="s1">'enabled'</span> <span class="o">=&gt;</span> <span class="nc">Yii</span><span class="o">::</span><span class="nv">$app</span><span class="o">-&gt;</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">isGet</span><span class="p">]))</span> <span class="p">{</span>

    <span class="c1">// ... generar contenido aquí ...</span>

    <span class="nv">$this</span><span class="o">-&gt;</span><span class="nf">endCache</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="caché-de-páginas"><a href="#header-2"></a>Caché de páginas</h2>

<p>La caché de páginas se refiere a guardar el contenido de toda una página en el almacenamiento de caché del servidor. Posteriormente, cuando la misma página sea requerida de nuevo, su contenido será devuelto desde la caché en vez de volver a generarlo desde cero.</p>

<p>El almacenamiento en caché de páginas está soportado por <code class="language-plaintext highlighter-rouge">yii\filters\PageCache</code>, un filtro de acción. Puede ser utilizado de la siguiente forma en un controlador:</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">function</span> <span class="n">behaviors</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span>
        <span class="p">[</span>
            <span class="s1">'class'</span> <span class="o">=&gt;</span> <span class="s1">'yii\filters\PageCache'</span><span class="p">,</span>
            <span class="s1">'only'</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">'index'</span><span class="p">],</span>
            <span class="s1">'duration'</span> <span class="o">=&gt;</span> <span class="mi">60</span><span class="p">,</span>
            <span class="s1">'variations'</span> <span class="o">=&gt;</span> <span class="p">[</span>
                <span class="nc">Yii</span><span class="o">::</span><span class="nv">$app</span><span class="o">-&gt;</span><span class="n">language</span><span class="p">,</span>
            <span class="p">],</span>
            <span class="s1">'dependency'</span> <span class="o">=&gt;</span> <span class="p">[</span>
                <span class="s1">'class'</span> <span class="o">=&gt;</span> <span class="s1">'yii\caching\DbDependency'</span><span class="p">,</span>
                <span class="s1">'sql'</span> <span class="o">=&gt;</span> <span class="s1">'SELECT COUNT(*) FROM post'</span><span class="p">,</span>
            <span class="p">],</span>
        <span class="p">],</span>
    <span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<p>El código anterior establece que el almacenamiento de páginas en caché debe ser utilizado sólo en la acción index; el contenido de la página debería almacenarse durante un máximo de 60 segundos y ser variado por el idioma actual de la aplicación; además, el almacenamiento de la página en caché debería ser invalidado si el número total de artículos ha cambiado.</p>

<p>Como puedes ver, la caché de páginas es muy similar a la caché de fragmentos. Ambos soportan opciones tales como <code class="language-plaintext highlighter-rouge">duration</code>, <code class="language-plaintext highlighter-rouge">dependencies</code>, <code class="language-plaintext highlighter-rouge">variations</code>, y <code class="language-plaintext highlighter-rouge">enabled</code>. Su principal diferencia es que la caché de páginas está implementado como un filtro de acción mientras que la caché de fragmentos se hace en un <em>widget</em>.</p>

<h2 id="caché-http"><a href="#header-2"></a>Caché HTTP</h2>

<p>Las aplicaciones Web pueden hacer uso de la caché en el lado del cliente para así ahorrar tiempo y recursos para generar y transmitir el mismo contenido una y otra vez.</p>

<p>Para usar la caché del lado del cliente, puedes configurar <code class="language-plaintext highlighter-rouge">yii\filters\HttpCache</code> como un filtro en el controlador para aquellas acciones cuyo resultado deba estar almacenado en la caché en el lado del cliente. <code class="language-plaintext highlighter-rouge">HttpCache</code> solo funciona en peticiones <code class="language-plaintext highlighter-rouge">GET</code> y <code class="language-plaintext highlighter-rouge">HEAD</code>. Puede manejar tres tipos de cabeceras (headers) HTTP relacionadas en este tipo de consultas:</p>

<h3 id="la-cabecera-last-modified"><a href="#header-3"></a>La Cabecera Last-Modified</h3>

<p>La cabecera Last-Modified usa un sello de tiempo para indicar si la página ha sido modificada desde que el cliente la almacena en la caché.</p>

<p>El siguiente es un ejemplo haciendo uso de la cabecera Last-Modified:</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">function</span> <span class="n">behaviors</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span>
        <span class="p">[</span>
            <span class="s1">'class'</span> <span class="o">=&gt;</span> <span class="s1">'yii\filters\HttpCache'</span><span class="p">,</span>
            <span class="s1">'only'</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">'index'</span><span class="p">],</span>
            <span class="s1">'lastModified'</span> <span class="o">=&gt;</span> <span class="k">function</span> <span class="p">(</span><span class="nv">$action</span><span class="p">,</span> <span class="nv">$params</span><span class="p">)</span> <span class="p">{</span>
                <span class="nv">$q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Yii\db\Query</span><span class="p">();</span>
                <span class="k">return</span> <span class="nv">$q</span><span class="o">-&gt;</span><span class="nf">from</span><span class="p">(</span><span class="s1">'post'</span><span class="p">)</span><span class="o">-&gt;</span><span class="nb">max</span><span class="p">(</span><span class="s1">'updated_at'</span><span class="p">);</span>
            <span class="p">},</span>
        <span class="p">],</span>
    <span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<p>El código anterior establece que la memoria caché HTTP debe ser habilitada únicamente por la acción index. Se debe generar una cabecera HTTP Last-Modified basado en el último tiempo de actualización de los artículos. Cuando un navegador visita la página index la primera vez, la página será generada en el servidor y enviada al navegador; Si el navegador visita la misma página de nuevo y no ningún artículo modificado durante el período, el servidor no volverá a regenerar la página, y el navegador usará la versión caché del lado del cliente. Como resultado, la representación del lado del servidor y la transmisión del contenido de la página son ambos omitidos.</p>

<h3 id="la-cabecera-etag"><a href="#header-3"></a>La Cabecera ETag</h3>

<p>La cabecera <strong>Entity Tag</strong> (o para abreviar ETag) usa un <em>hash</em> para representar el contenido de una página. Si la página ha sido cambiada, el <em>hash</em> también cambiará. Al comparar el <em>hash</em> guardado en el lado del cliente con el hash generado en el servidor, la caché puede determinar si la página ha cambiado y deber ser retransmitida.</p>

<p>El siguiente es un ejemplo de cómo usar la cabecera ETag:</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">function</span> <span class="n">behaviors</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span>
        <span class="p">[</span>
            <span class="s1">'class'</span> <span class="o">=&gt;</span> <span class="s1">'yii\filters\HttpCache'</span><span class="p">,</span>
            <span class="s1">'only'</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">'view'</span><span class="p">],</span>
            <span class="s1">'etagSeed'</span> <span class="o">=&gt;</span> <span class="k">function</span> <span class="p">(</span><span class="nv">$action</span><span class="p">,</span> <span class="nv">$params</span><span class="p">)</span> <span class="p">{</span>
                <span class="nv">$post</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="nf">findModel</span><span class="p">(</span><span class="nc">Yii</span><span class="o">::</span><span class="nv">$app</span><span class="o">-&gt;</span><span class="n">request</span><span class="o">-&gt;</span><span class="nf">get</span><span class="p">(</span><span class="s1">'id'</span><span class="p">));</span>
                <span class="k">return</span> <span class="nb">serialize</span><span class="p">([</span><span class="nv">$post</span><span class="o">-&gt;</span><span class="n">title</span><span class="p">,</span> <span class="nv">$post</span><span class="o">-&gt;</span><span class="n">content</span><span class="p">]);</span>
            <span class="p">},</span>
        <span class="p">],</span>
    <span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<p>El código anterior establece que la caché HTTP debe ser activada únicamente para la acción <em>view</em>. Debería generar una cabecera HTTP ETag basándose en el título y contenido del artículo consultado. Cuando un navegador visita la página view por primera vez, la página se generará en el servidor y será enviada al navegador; Si el navegador visita la misma página de nuevo y no ha ocurrido un cambio en el título o contenido del artículo, el servidor no volverá a generar la página, y el navegador usará la versión guardada en la caché del lado del cliente. Como resultado, la representación del lado del servidor y la transmisión del contenido de la página son ambos omitidos.</p>

<p>ETags permiten estrategias de almacenamiento de caché más complejas y/o mucho más precisas que las cabeceras Last-Modified. Por ejemplo, un ETag puede ser invalidado si el sitio Web ha cambiado de tema (theme).</p>

<p>La generación de un ETag que requiera muchos recursos puede echar por tierra el propósito de estar usando HttpCache e introducir una sobrecarga innecesaria, ya que debe ser re-evaluada en cada solicitud (request). Trata de encontrar una expresión sencilla para invalidar la caché si la página ha sido modificada.</p>

<h3 id="la-cabecera-cache-control"><a href="#header-3"></a>La Cabecera Cache-Control</h3>

<p>La cabecera Cache-Control especifica la directiva general de la caché para páginas. Puedes enviarla configurando la propiedad <code class="language-plaintext highlighter-rouge">yii\filters\HttpCache::$cacheControlHeader</code> con el valor de la cabecera. Por defecto, la siguiente cabecera será enviada:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Cache-Control: public, max-age=3600
</code></pre></div></div>

<blockquote>
  <p>Cuando una página utiliza la sesión, PHP enviará automáticamente cabeceras HTTP relacionadas con la caché tal y como se especifican en session.cache_limiter de la configuración INI de PHP. Estas cabeceras pueden interferir o deshabilitar el almacenamiento de caché que desees de <code class="language-plaintext highlighter-rouge">HttpCache</code>. Para evitar este problema, por defecto <code class="language-plaintext highlighter-rouge">HttpCache</code> deshabilitará automáticamente el envío de estas cabeceras. Si deseas modificar este comportamiento, tienes que configurar la propiedad <code class="language-plaintext highlighter-rouge">yii\filters\HttpCache::$sessionCacheLimiter</code>. La propiedad puede tomar un valor de cadena, incluyendo <code class="language-plaintext highlighter-rouge">public</code>, <code class="language-plaintext highlighter-rouge">private</code>, <code class="language-plaintext highlighter-rouge">private_no_expire</code>, and <code class="language-plaintext highlighter-rouge">nocache</code>.</p>
</blockquote>

<blockquote>
  <p>Los robots de motores de búsqueda tienden a respetar las cabeceras de caché. Dado que algunos <em>crawlers</em> tienen limitado el número de páginas que pueden rastrear por dominios dentro de un cierto período de tiempo, la introducción de cabeceras de caché pueden ayudar a la indexación del sitio Web y reducir el número de páginas que deben ser procesadas.</p>
</blockquote>

<h3 id="limitaciones"><a href="#header-3"></a>Limitaciones</h3>

<p>El almacenamiento en caché de consultas no funciona con los resultados de consulta que contienen controladores de recursos. Por ejemplo, cuando se utiliza el tipo de columna BLOB en algunos DBMS, el resultado de la consulta devolverá un recurso para manejar los datos de la columna.</p>

<p>Algunos sistemas de almacenamiento caché tienen limitación de tamaño. Por ejemplo, memcache limita el tamaño máximo de cada entrada a 1MB. Por lo tanto, si el tamaño de un resultado de la consulta excede ese límite, el almacenamiento en caché fallará.</p>

<h1 id="fuentes"><a href="#header-1"></a>Fuentes</h1>

<ul>
  <li><a href="https://www.yiiframework.com/doc/guide/2.0/es/caching-data">Almacenamiento de Datos en Caché?</a></li>
  <li><a href="https://www.youtube.com/watch?v=aRh2m_1nZF8/">Yii 2.0 Part 17 - Caching</a></li>
  <li><a href="https://www.itworkman.com/169213.html/">What are yii2’s cache dependencies? How do I use cache dependencies?</a></li>
  <li><a href="https://kb.zensoft.hu/yii2-caching-and-activerecord/#caching-in-a-search-model/">Yii2 Optimization &amp; Caching and ActiveRecord</a></li>
</ul>

<p>habilitar log 
configurar base de datos</p>

</article>
      </section>
    </div>
  </div>

   <footer>
  <a href="https://github.com/EvaVillarrealGuzman">
    <span>
        <b>EvaVillarrealGuzman</b>
    </span>
    
    <span>© 2022</span>
  </a>
</footer>

  
    <script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'G-JLF4M03LEM', 'auto');
  ga('send', 'pageview');
</script>
  
</body>

</html>