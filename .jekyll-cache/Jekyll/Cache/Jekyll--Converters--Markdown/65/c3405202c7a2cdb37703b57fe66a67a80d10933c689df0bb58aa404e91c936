I"W<p>Performance is the main factor in the quality of an application. Performance depends on how we are coding and configure the infrastructure. Performance optimization is an important technique to consider, before delivering any application. Because it will impact the user experience. In this article, we are going to explore performance optimization techniques in React.</p>

<h1 id="reactfragment"><a href="#header-1"></a>React.Fragment</h1>

<p>Muchas veces pasa que queremos renderizar un conjunto de elementos dentro de un y se agrupan estos elementos dentro de un elemento padre “div”:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;div&gt;</span>
    <span class="nt">&lt;h1&gt;</span>Title<span class="nt">&lt;/h1&gt;</span>
    <span class="nt">&lt;p&gt;</span>Content<span class="nt">&lt;/p&gt;</span>
<span class="nt">&lt;/div&gt;</span>
</code></pre></div></div>

<p>Esto agrega un nodo extra al DOM, el cual es innecesario ya que solo tiene la función de agrupar elementos. Esto puede afectar a la performance.</p>

<p>Para agrupar elementos existe <React.Fragment>, el cuál no agrega ningún nodo extra:</React.Fragment></p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;React.Fragment&gt;</span>
    <span class="nt">&lt;h1&gt;</span>Title<span class="nt">&lt;/h1&gt;</span>
    <span class="nt">&lt;p&gt;</span>Content<span class="nt">&lt;/p&gt;</span>
<span class="nt">&lt;/React.Fragment&gt;</span>
</code></pre></div></div>

<p>React.Fragment tiene la sintaxis corta que es  &lt;&gt;&lt;/&gt;. Por lo que el código de arriba también se puede escribir:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;&gt;</span>
    <span class="nt">&lt;h1&gt;</span>Title<span class="nt">&lt;/h1&gt;</span>
    <span class="nt">&lt;p&gt;</span>Content<span class="nt">&lt;/p&gt;</span>
<span class="nt">&lt;/&gt;</span>
</code></pre></div></div>

<h1 id="usar-production-en-el-mode-de-webpack"><a href="#header-1"></a>Usar <em>production</em> en el <em>mode</em> de <em>webpack</em></h1>

<p>En caso de usar <em>webpack</em> como empaquetador de módulos (<em>bundler</em>) debería configurar la opción <em>mode</em> como <em>production</em> para el archivo de configuración de producción. Esto hará que <em>webpack</em> ejecute optimizaciones durante el empaquetado de la aplicación.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1">// webpack.production.config.js</span>
<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">mode</span><span class="p">:</span> <span class="dl">'</span><span class="s1">production</span><span class="dl">'</span>
<span class="p">};</span>

<span class="c1">//o se puede pasar como argumento en el CLI</span>
<span class="nx">webpack</span> <span class="o">--</span><span class="nx">mode</span><span class="o">=</span><span class="nx">production</span>
</code></pre></div></div>

<h1 id="implemente-el-método-shouldcomponentupdate"><a href="#header-1"></a>Implemente el método shouldComponentUpdate()</h1>

<p>Cuando una propiedad o estado de un componente cambia, React decide si es necesario actualizar el DOM comparando el elemento recién retornado con el previamente renderizado. Si no son iguales, React actualizará el DOM.</p>

<p>Aunque React solo actualiza los nodos DOM modificados, el re-renderizado aun lleva algo de tiempo. En muchos casos no es un problema, pero si la desaceleración es notable puedes acelerar el proceso anulando la función del ciclo de vida shouldComponentUpdate, el cual se ejecuta antes de que el proceso de re-renderizado comience, es decir, cuando nuevos <em>props</em> son recibidos o algún estado cambia. La implementación por defecto de esta función retorna true, permitiendo a React hacer la actualización, incluso si ningún <em>props</em> o estado ha cambiado (los valores actuales y previos son los mismos).</p>

<p>Si sabes que en algunas situaciones tu componente no necesita actualizarse, puedes retornar false desde shouldComponentUpdate para omitir todo el proceso de renderizacion, incluida la invocación de render() en este componente y debajo de él.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">React</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">react</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">class</span> <span class="nx">TestComponent</span> <span class="kd">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">super</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="p">{</span>
      <span class="na">data</span><span class="p">:</span> <span class="dl">""</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="nx">handleClick</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">value</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">"</span><span class="s2">textvalue</span><span class="dl">"</span><span class="p">).</span><span class="nx">value</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">({</span> <span class="na">data</span><span class="p">:</span> <span class="nx">value</span> <span class="p">})</span>
  <span class="p">}</span>

  <span class="nx">shouldComponentUpdate</span><span class="p">(</span><span class="nx">nextProps</span><span class="p">,</span> <span class="nx">nextState</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">nextState</span><span class="p">.</span><span class="nx">data</span> <span class="o">===</span> <span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">data</span><span class="p">)</span>
      <span class="k">return</span> <span class="kc">false</span>
    <span class="k">return</span> <span class="kc">true</span>
  <span class="p">}</span>

  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Rendering</span><span class="dl">"</span><span class="p">);</span>
    <span class="k">return</span> <span class="p">(</span>
      <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="nx">input</span> <span class="nx">id</span><span class="o">=</span><span class="dl">"</span><span class="s2">textvalue</span><span class="dl">"</span> <span class="nx">type</span><span class="o">=</span><span class="dl">"</span><span class="s2">text</span><span class="dl">"</span> <span class="o">/&gt;</span>
        <span class="o">&lt;</span><span class="nx">button</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">handleClick</span><span class="p">}</span><span class="o">&gt;</span><span class="nx">Click</span><span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span>        <span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">data</span><span class="p">}</span>
      <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>    <span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Si el código de arriba no tuviera el método shouldComponentUpdate implementado, el componente se vuelve a renderizar cada vez que se hace click en un botón (incluso si el <em>input</em> de texto tiene el mismo valor).</p>

<h1 id="use-lazy-loading-components"><a href="#header-1"></a>Use Lazy loading components</h1>

<p>Lazy loading is an important concept in modern web apps which allows us to load only the resources (scripts, images, etc.) we really needed.  Instead of loading the entire web page and rendering in the browser all at once, just render the critical component first, then render the remaining components later or when required.</p>

<p>There are two features to implement lazy loading in React applications.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>React.lazy() - React.lazy() is the function that allows implementing the dynamic import for regular components in React.
React.Suspense - React.suspense has a fallback property which takes the react element that wants to render while the component is being loaded using React.lazy.
</code></pre></div></div>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">React</span><span class="p">,</span> <span class="p">{</span> <span class="nx">Suspense</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react</span><span class="dl">'</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">LazyComponent</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">lazy</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="k">import</span><span class="p">(</span><span class="dl">'</span><span class="s1">./LazyComponent</span><span class="dl">'</span><span class="p">));</span>

<span class="kd">function</span> <span class="nx">MyComponent</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
  <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="nx">Suspense</span> <span class="nx">fallback</span><span class="o">=</span><span class="p">{</span><span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="nx">Loading</span><span class="p">....</span><span class="o">&lt;</span><span class="sr">/div&gt;}</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="nx">LazyComponent</span> <span class="o">/&gt;</span>
    <span class="o">&lt;</span><span class="sr">/Suspense</span><span class="err">&gt;
</span>  <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span> <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="reactpurecomponent"><a href="#header-1"></a>React.PureComponent</h1>

<p>Instead of implementing the “shouldComponentUpdate()” lifecycle method, we can use React.PureComponent.
A React.PureComponent is exactly the same as React.Component that checks the props and state values(shallow comparison) and decides whether the component needs to re-render or not.
No need to implement the “shouldComponentUpdate()” life cycle method explicitly. React.PureComponent optimizes the class components by reducing the number of unwanted renders.
It performs a shallow comparison only when
    props or states contain primitive data.
    props and states have complex data, but know when to call forceUpdate() to update the component.</p>

<p>The above “TestComponent” has been implemented using “React.PureComponent”. Here component itself handled the “shouldComponentUpdate()” method for both shallow comparison and re-rendering.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">React</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">react</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">class</span> <span class="nx">TestComponent</span> <span class="kd">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">PureComponent</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">super</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="p">{</span>
      <span class="na">data</span><span class="p">:</span> <span class="dl">""</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="nx">handleClick</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">value</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">"</span><span class="s2">textvalue</span><span class="dl">"</span><span class="p">).</span><span class="nx">value</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">({</span> <span class="na">data</span><span class="p">:</span> <span class="nx">value</span> <span class="p">})</span>
  <span class="p">}</span>
  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Rendering</span><span class="dl">"</span><span class="p">);</span>
    <span class="k">return</span> <span class="p">(</span>
      <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="nx">input</span> <span class="nx">id</span><span class="o">=</span><span class="dl">"</span><span class="s2">textvalue</span><span class="dl">"</span> <span class="nx">type</span><span class="o">=</span><span class="dl">"</span><span class="s2">text</span><span class="dl">"</span> <span class="o">/&gt;</span>
        <span class="o">&lt;</span><span class="nx">button</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">handleClick</span><span class="p">}</span><span class="o">&gt;</span><span class="nx">Click</span><span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span>        <span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">data</span><span class="p">}</span>
      <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>    <span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="use-memoization"><a href="#header-1"></a>Use Memoization</h1>

<p>Memoization is an optimization technique to increase the performance of the application by storing the results and returning the cached result when the same inputs occur again. 
React.memo or useMemo is used to optimize the performance with the help of caching the components in React.
React.memo is a higher-order component and it’s similar to React.PureComponent but for using functional components instead of class components.
When functional component is rendered using React.Memo or useMemo then its result has saved in the memory and next time the component getting called with the same props then the cached result will return without any execution.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">React</span><span class="p">,</span> <span class="p">{</span> <span class="nx">Suspense</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react</span><span class="dl">'</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">LazyComponent</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">lazy</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="k">import</span><span class="p">(</span><span class="dl">'</span><span class="s1">./LazyComponent</span><span class="dl">'</span><span class="p">));</span>

<span class="kd">function</span> <span class="nx">MyComponent</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
  <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="nx">Suspense</span> <span class="nx">fallback</span><span class="o">=</span><span class="p">{</span><span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="nx">Loading</span><span class="p">....</span><span class="o">&lt;</span><span class="sr">/div&gt;}</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="nx">LazyComponent</span> <span class="o">/&gt;</span>
    <span class="o">&lt;</span><span class="sr">/Suspense</span><span class="err">&gt;
</span>  <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span> <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>https://ichi.pro/es/optimizacion-de-las-aplicaciones-react-con-componentes-de-funcion-react-memo-usememo-lists-keys-76395047615674</p>

<p>https://alihacks.com/react-detras-de-escena-y-tecnicas-de-optimizacion-usememo-usecallback-react-memo/</p>

<p>https://platzi.com/clases/2118-react-hooks/34007-optimizacion-de-componentes-en-react-con-reactmemo/</p>

<h1 id="use-functionalstateless-components"><a href="#header-1"></a>Use Functional/Stateless Components</h1>

<p>The functional component prevents the construction of the class instance. It reduces the overall bundle size better than classes.</p>

<h1 id="binding-the-functions-in-early"><a href="#header-1"></a>Binding the Functions in Early</h1>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Bind the functions with elements in the render function will cause the performance issue. Because render() function to create a new function on every render.
If the arrow function is used inside the render() function, then each time browser executes an arrow function ("=&gt;") statement and it create a new function object. This can be an expensive operation depends on the situation.
If you are using the arrow function as props then it will break the performance optimizations such as shouldComponentUpdate and PureComponent.
</code></pre></div></div>

<h1 id="virtualizing-the-long-lists"><a href="#header-1"></a>Virtualizing the long lists</h1>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>If you want to render a large list of data, then just render the smaller portion of the list at a time (limited to viewport of the component) and render the remaining data whenever scrolled. This is called "windowing".
It will reduce the re-rendering time and avoid the number of DOM nodes to be created. 
</code></pre></div></div>

<p>https://reactjs.org/docs/optimizing-performance.html</p>

<h1 id="throttling-and-debouncing"><a href="#header-1"></a>Throttling and Debouncing</h1>

<p>Throttling and Debouncing are important optimization concepts to avoid multiple API calls.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Throttling
Throttling means executing the function at regular intervals, which means once the function is executed, it will start again only after a specified amount of time is over.
 
Debouncing
Debouncing means the function will execute when a user hasn't carried out an event in a specified amount of time.
</code></pre></div></div>

<h1 id="the-power-of-not-mutating-data"><a href="#header-1"></a>The Power Of Not Mutating Data</h1>

<p>https://reactjs.org/docs/optimizing-performance.html</p>

<h1 id="avoid-implying-inline-style-attribute"><a href="#header-1"></a>Avoid Implying Inline Style Attribute</h1>

<h1 id="dependency-optimization"><a href="#header-1"></a>Dependency Optimization</h1>

<h1 id="reactjs-developer-can-use-multiple-chunk-files"><a href="#header-1"></a>ReactJS developer can use multiple Chunk Files</h1>

<h1 id="bundle-analitic"><a href="#header-1"></a>Bundle Analitic</h1>

<p>medir con eact-addons-perf p</p>

<p>https://medium.com/swlh/9-performance-optimization-strategies-for-reactjs-development-36f6d03a0912</p>

<p>https://www.toptal.com/react/componentes-react-eficientes-una-guia-para-optimizar-el-desempeno-de-react</p>

<p>https://latteandcode.medium.com/react-hooks-para-optimizar-el-rendimiento-7e4e5ec4894</p>

<p>https://ichi.pro/es/22-tecnicas-de-optimizacion-del-rendimiento-de-react-230208723231561</p>

<p>https://ichi.pro/es/tecnicas-de-optimizacion-del-rendimiento-en-react-123769334290435</p>

<p>https://ourcodeworld.co/articulos/leer/934/top-9-las-mejores-tecnicas-de-optimizacion-para-aplicaciones-react</p>
:ET