I"È~<p>Performance is the main factor in the quality of an application. Performance depends on how we are coding and configure the infrastructure. Performance optimization is an important technique to consider, before delivering any application. Because it will impact the user experience. In this article, we are going to explore performance optimization techniques in React.</p>

<h1 id="reactfragment"><a href="#header-1"></a>React.Fragment</h1>

<p>Muchas veces pasa que queremos renderizar un conjunto de elementos dentro de un y se agrupan estos elementos dentro de un elemento padre ‚Äúdiv‚Äù:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;div&gt;</span>
    <span class="nt">&lt;h1&gt;</span>Title<span class="nt">&lt;/h1&gt;</span>
    <span class="nt">&lt;p&gt;</span>Content<span class="nt">&lt;/p&gt;</span>
<span class="nt">&lt;/div&gt;</span>
</code></pre></div></div>

<p>Esto agrega un nodo extra al DOM, el cual es innecesario ya que solo tiene la funci√≥n de agrupar elementos. Esto puede afectar a la performance.</p>

<p>Para agrupar elementos existe <React.Fragment>, el cu√°l no agrega ning√∫n nodo extra:</React.Fragment></p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;React.Fragment&gt;</span>
    <span class="nt">&lt;h1&gt;</span>Title<span class="nt">&lt;/h1&gt;</span>
    <span class="nt">&lt;p&gt;</span>Content<span class="nt">&lt;/p&gt;</span>
<span class="nt">&lt;/React.Fragment&gt;</span>
</code></pre></div></div>

<p>React.Fragment tiene la sintaxis corta que es  &lt;&gt;&lt;/&gt;. Por lo que el c√≥digo de arriba tambi√©n se puede escribir:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;&gt;</span>
    <span class="nt">&lt;h1&gt;</span>Title<span class="nt">&lt;/h1&gt;</span>
    <span class="nt">&lt;p&gt;</span>Content<span class="nt">&lt;/p&gt;</span>
<span class="nt">&lt;/&gt;</span>
</code></pre></div></div>

<h1 id="usar-production-en-el-mode-de-webpack"><a href="#header-1"></a>Usar <em>production</em> en el <em>mode</em> de <em>webpack</em></h1>

<p>En caso de usar <em>webpack</em> como empaquetador de m√≥dulos (<em>bundler</em>) deber√≠a configurar la opci√≥n <em>mode</em> como <em>production</em> para el archivo de configuraci√≥n de producci√≥n. Esto har√° que <em>webpack</em> ejecute optimizaciones durante el empaquetado de la aplicaci√≥n.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1">// webpack.production.config.js</span>
<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">mode</span><span class="p">:</span> <span class="dl">'</span><span class="s1">production</span><span class="dl">'</span>
<span class="p">};</span>

<span class="c1">//o se puede pasar como argumento en el CLI</span>
<span class="nx">webpack</span> <span class="o">--</span><span class="nx">mode</span><span class="o">=</span><span class="nx">production</span>
</code></pre></div></div>

<h1 id="implemente-el-m√©todo-shouldcomponentupdate"><a href="#header-1"></a>Implemente el m√©todo shouldComponentUpdate()</h1>

<p>Cuando una propiedad o estado de un componente cambia, React decide si es necesario actualizar el DOM comparando el elemento reci√©n retornado con el previamente renderizado. Si no son iguales, React actualizar√° el DOM.</p>

<p>Aunque React solo actualiza los nodos DOM modificados, el re-renderizado aun lleva algo de tiempo. En muchos casos no es un problema, pero si la desaceleraci√≥n es notable puedes acelerar el proceso anulando la funci√≥n del ciclo de vida shouldComponentUpdate, el cual se ejecuta antes de que el proceso de re-renderizado comience, es decir, cuando nuevos <em>props</em> son recibidos o alg√∫n estado cambia. La implementaci√≥n por defecto de esta funci√≥n retorna true, permitiendo a React hacer la actualizaci√≥n, incluso si ning√∫n <em>props</em> o estado ha cambiado (los valores actuales y previos son los mismos).</p>

<p>Si sabes que en algunas situaciones tu componente no necesita actualizarse, puedes retornar false desde shouldComponentUpdate para omitir todo el proceso de renderizacion, incluida la invocaci√≥n de render() en este componente y debajo de √©l.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">React</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">react</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">class</span> <span class="nx">TestComponent</span> <span class="kd">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">super</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="p">{</span>
      <span class="na">data</span><span class="p">:</span> <span class="dl">""</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="nx">handleClick</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">value</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">"</span><span class="s2">textvalue</span><span class="dl">"</span><span class="p">).</span><span class="nx">value</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">({</span> <span class="na">data</span><span class="p">:</span> <span class="nx">value</span> <span class="p">})</span>
  <span class="p">}</span>

  <span class="nx">shouldComponentUpdate</span><span class="p">(</span><span class="nx">nextProps</span><span class="p">,</span> <span class="nx">nextState</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">nextState</span><span class="p">.</span><span class="nx">data</span> <span class="o">===</span> <span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">data</span><span class="p">)</span>
      <span class="k">return</span> <span class="kc">false</span>
    <span class="k">return</span> <span class="kc">true</span>
  <span class="p">}</span>

  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Rendering</span><span class="dl">"</span><span class="p">);</span>
    <span class="k">return</span> <span class="p">(</span>
      <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="nx">input</span> <span class="nx">id</span><span class="o">=</span><span class="dl">"</span><span class="s2">textvalue</span><span class="dl">"</span> <span class="nx">type</span><span class="o">=</span><span class="dl">"</span><span class="s2">text</span><span class="dl">"</span> <span class="o">/&gt;</span>
        <span class="o">&lt;</span><span class="nx">button</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">handleClick</span><span class="p">}</span><span class="o">&gt;</span><span class="nx">Click</span><span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span>        <span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">data</span><span class="p">}</span>
      <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>    <span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Si el c√≥digo de arriba no tuviera el m√©todo shouldComponentUpdate implementado, el componente se vuelve a renderizar cada vez que se hace click en un bot√≥n (incluso si el <em>input</em> de texto tiene el mismo valor).</p>

<h1 id="reactpurecomponent"><a href="#header-1"></a>React.PureComponent</h1>

<p>En lugar de implementar shouldComponentUpdate, podemos usar React.PureComponent.</p>

<p>Un React.PureComponent es lo mismo que un React.Component que implementa una funci√≥n shouldComponentUpdate() con una comparaci√≥n superficial. Es decir, chequea los <em>props</em> y los valores de los estados superficiales y decide si el componente necesita renderizar o no. De esta manera React.PureComponent optimiza los componentes de la clase reduciendo el n√∫mero de renderizados no deseados.</p>

<p>Debido a que s√≥lo hace una comparaci√≥n superficial, no puede usarlo si las propiedades o el estado han sido mutados de una manera que una comparaci√≥n superficial pasar√≠a por alto. Esto puede ser un problema con estructuras de datos m√°s complejas.</p>

<p>Por ejemplo, en el siguiente c√≥digo el problema es que PureComponent har√° una comparaci√≥n simple entre los valores antiguos y nuevos de this.props.words. Dado que este c√≥digo muta la matriz wordsen el m√©todo handleClick de WordAdder, los valores antiguos y nuevos de this.props.words se comparar√°n como iguales, aunque las palabras actuales de la matriz hayan cambiado. La ListOfWords no se actualizar√° a pesar de que tiene nuevas palabras que se deben renderizar.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">CounterButton</span> <span class="kd">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">PureComponent</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">super</span><span class="p">(</span><span class="nx">props</span><span class="p">);</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="p">{</span><span class="na">count</span><span class="p">:</span> <span class="mi">1</span><span class="p">};</span>
  <span class="p">}</span>

  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span>
      <span class="o">&lt;</span><span class="nx">button</span>
        <span class="nx">color</span><span class="o">=</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">color</span><span class="p">}</span>
        <span class="nx">onClick</span><span class="o">=</span><span class="p">{()</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">(</span><span class="nx">state</span> <span class="o">=&gt;</span> <span class="p">({</span><span class="na">count</span><span class="p">:</span> <span class="nx">state</span><span class="p">.</span><span class="nx">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">}))}</span><span class="o">&gt;</span>
        <span class="nx">Count</span><span class="p">:</span> <span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">count</span><span class="p">}</span>
      <span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span>    <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Por lo tanto, React.PureComponent es √∫til solo cuando:</p>
<ul>
  <li><em>props</em> y estados contienen datos primitivos</li>
  <li><em>props</em> y estados tienen datos complejos pero saben cu√°ndo llamar a forceUpdate() para actualizar el componente</li>
</ul>

<p>La implementaci√≥n de shouldComponentUpdate en el ejemplo anterior de TestComponent se podr√≠a implementar como React.PureComponent de la siguiente manera:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">React</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">react</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">class</span> <span class="nx">TestComponent</span> <span class="kd">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">PureComponent</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">super</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="p">{</span>
      <span class="na">data</span><span class="p">:</span> <span class="dl">""</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="nx">handleClick</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">value</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">"</span><span class="s2">textvalue</span><span class="dl">"</span><span class="p">).</span><span class="nx">value</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">({</span> <span class="na">data</span><span class="p">:</span> <span class="nx">value</span> <span class="p">})</span>
  <span class="p">}</span>
  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Rendering</span><span class="dl">"</span><span class="p">);</span>
    <span class="k">return</span> <span class="p">(</span>
      <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="nx">input</span> <span class="nx">id</span><span class="o">=</span><span class="dl">"</span><span class="s2">textvalue</span><span class="dl">"</span> <span class="nx">type</span><span class="o">=</span><span class="dl">"</span><span class="s2">text</span><span class="dl">"</span> <span class="o">/&gt;</span>
        <span class="o">&lt;</span><span class="nx">button</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">handleClick</span><span class="p">}</span><span class="o">&gt;</span><span class="nx">Click</span><span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span>        <span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">data</span><span class="p">}</span>
      <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>    <span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="usar-memorizaci√≥n"><a href="#header-1"></a>Usar memorizaci√≥n</h1>

<p>Memorizaci√≥n es una t√©cnica de optimizaci√≥n para incrementar la performance de la aplicaci√≥n guardando los resultados y devolviendo el resultado en cach√© cuando se repiten las mismas entradas.</p>

<p>React provee React.memo y useMemo para memorizaci√≥n, los cuales guardan en cach√© componentes.</p>

<p>React.memo es un componente de alto nivel para usar en componentes funcionales. Cuando el componente funcional se procesa usando React.Memo o useMemo, entonces su resultado se ha guardado en la memoria y la pr√≥xima vez que se llame al componente con los mismos <em>props</em>, el resultado en cach√© regresar√° sin ninguna ejecuci√≥n.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">UserDisplay</span> <span class="o">=</span> <span class="p">(</span><span class="nx">userDetails</span><span class="p">)</span> <span class="o">=&gt;</span><span class="p">{</span>
    <span class="kd">const</span> <span class="p">{</span><span class="nx">name</span><span class="p">,</span> <span class="nx">age</span><span class="p">,</span> <span class="nx">address</span><span class="p">}</span> <span class="o">=</span> <span class="nx">userDetails</span><span class="p">;</span>

    <span class="k">return</span> <span class="p">(</span>
        <span class="o">&lt;&gt;</span>
            <span class="o">&lt;</span><span class="nx">h4</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">name</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/h4</span><span class="err">&gt;
</span>            <span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">age</span><span class="p">}</span> <span class="p">,</span> <span class="p">{</span><span class="nx">address</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/p</span><span class="err">&gt;
</span>        <span class="o">&lt;</span><span class="sr">/</span><span class="err">&gt;
</span>    <span class="p">)</span>
<span class="p">}</span>
<span class="k">export</span> <span class="k">default</span> <span class="nx">React</span><span class="p">.</span><span class="nx">memo</span><span class="p">(</span><span class="nx">UserDisplay</span><span class="p">);</span>
<span class="c1">// First - UserDisplay component gets called and executed, and then rendered.</span>
<span class="o">&lt;</span><span class="nx">UserDisplay</span>
  <span class="nx">name</span><span class="o">=</span><span class="dl">"</span><span class="s2">Test</span><span class="dl">"</span>
  <span class="nx">age</span><span class="o">=</span><span class="dl">"</span><span class="s2">30</span><span class="dl">"</span>
  <span class="nx">address</span><span class="o">=</span><span class="dl">"</span><span class="s2">Test address</span><span class="dl">"</span>
<span class="o">/&gt;</span>
<span class="c1">// Second - The cached result will render without any execution.</span>
<span class="o">&lt;</span><span class="nx">UserDisplay</span>
  <span class="nx">name</span><span class="o">=</span><span class="dl">"</span><span class="s2">Test</span><span class="dl">"</span>
  <span class="nx">age</span><span class="o">=</span><span class="dl">"</span><span class="s2">30</span><span class="dl">"</span>
  <span class="nx">address</span><span class="o">=</span><span class="dl">"</span><span class="s2">Test address</span><span class="dl">"</span>
<span class="o">/&gt;</span>
<span class="c1">// Third - UserDisplay component gets called and executed, and then rendered.(because here value of the name value different)</span>
<span class="o">&lt;</span><span class="nx">UserDisplay</span>
  <span class="nx">name</span><span class="o">=</span><span class="dl">"</span><span class="s2">New Test</span><span class="dl">"</span>
  <span class="nx">age</span><span class="o">=</span><span class="dl">"</span><span class="s2">30</span><span class="dl">"</span>
  <span class="nx">address</span><span class="o">=</span><span class="dl">"</span><span class="s2">Test address</span><span class="dl">"</span>
<span class="o">/&gt;</span>
</code></pre></div></div>

<h1 id="code-splitting"><a href="#header-1"></a><em>Code Splitting</em></h1>

<p>Primero es importante entender el concepto de <em>Lazy loading</em>, el cu√°l indica que los recursos (ima«µenes, <em>scripts</em>, etc.) deber√≠an ser cargados cuando realmente se necesitan. En lugar de cargar una p√°gina web entera y renderizarla en el navegador todo de una vez, solo renderiza los componente cr√≠ticos primero y luego aquellos componentes restantes o cuando se vayan requiriendo. De esta manera no perdemos tiempo ni memoria en procesos que no beneficiar√°n la experiencia del usuario del producto.</p>

<p><em>Code Splitting</em> es una t√©cnica que podemos tratar costos de cargar Javascript y cumplir con el concepto de <em>lazy loading</em> al mismo tiempo.  En lugar de entregar tu aplicaci√≥n en un √∫nico archivo, se divide en varios archivos. La p√°gina en principio solo renderiza los componente cr√≠ticos primero y luego aquellos componentes restantes o cuando se vayan requiriendo.</p>

<p>La forma en que le indicamos a <em>webpack</em> que queremos dividir en un c√≥digo en paquetes separados es mediante <em>dynamic imports</em>. La palabra clave <em>import</em> se puede usar como una funci√≥n que toma la ruta del m√≥dulo que queremos dividir en un paquete separado y devuelve una <em>promise</em>:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span><span class="p">(</span><span class="dl">'</span><span class="s1">/module/name/here</span><span class="dl">'</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="nx">module</span> <span class="o">=&gt;</span> <span class="p">...)</span>
</code></pre></div></div>

<p>Cuando el m√≥dulo es cargado y la promesa resulta, podemos acceder a lo que exporta.</p>

<p>React provee dos elementos para implementarlo:</p>

<ul>
  <li>React.lazy() - React.lazy() es la funci√≥n que permite implementar la importaci√≥n din√°mica para componentes regulares en React.</li>
  <li>React.Suspense - React.suspense tiene una propiedad <em>fallback</em> que toma el elemento react que quiere renderizar mientras el componente se carga usando React.lazy</li>
</ul>

<p>El <em>code splitting</em> se puede realizar en diferentes niveles:</p>

<h2 id="por-rutas">Por rutas</h2>

<p>The way we signal to Webpack what we want to split into a separate bundle is by using dynamic imports. The import keyword can be used as a function which takes the path to the module we want to be split in a separate bundle and returns a promise.</p>

<p>When the module is loaded and the promise resolves we can have access to what it exports. It‚Äôs important to note that if your module has a default export you need to get the default property from the module object in order to access it.</p>

<p>In the context of React, the modules which we will be splitting are going to be the different components. For that purpose we can use React Loadable. It gives us access to a higher order component to do the dynamic import.</p>

<p>Para las aplicaciones web con React de una sola p√°gina, normalmente terminamos uniendo todo nuestro c√≥digo JavaScript front-end en un archivo √∫nico minimizado. Esto funciona muy bien para aplicaciones web de tama√±o medio. Pero mientras la aplicaci√≥n comienza a crecer, entregar este archivo JavaScript unido al buscador como tal puede ser un proceso que consume mucho tiempo.</p>

<p>Si est√°s usando <em>webpack</em> para construir tu aplicaci√≥n, puedes impulsar su c√≥digo al separar sus capacidades para igualmente separar tu c√≥digo de aplicaci√≥n construida en varios ‚Äúchunks‚Äù (trozos) y entregarlos al buscador en los momentos necesarios.</p>

<p>Hay dos tipos de separaci√≥n: separaci√≥n de recursos y separaci√≥n de c√≥digo en demanda.</p>

<p>Con la separaci√≥n de recursos, separas contenido de recursos en varios archivos. Por ejemplo, al usar CommonsChunkPlugin, puedes extraer un c√≥digo com√∫n (como todas las bibliotecas externas) a un archivo ‚Äúchunk‚Äù propiamente. Al usar ExtractTextWebpackPlugin, puedes extraer todo c√≥digo CSS a un archivo CSS separado.</p>

<p>Este tipo de separaci√≥n te ayudar√° de dos maneras. Ayuda al buscador a almacenar aquellos recursos que cambian con menos frecuencia. Tambi√©n ayudar√° al buscador a tomar ventaja de la descarga paralela para reducir, potencialmente, el tiempo de carga.</p>

<p>Una caracter√≠stica m√°s notable de Webpack es la separaci√≥n del c√≥digo en demanda. Esto puede mantener la descarga inicial peque√±a al reducir el tiempo que toma cargar la aplicaci√≥n. El buscador puede, consecuentemente, descargar trozos de c√≥digo en demanda cuando la aplicaci√≥n lo necesite.</p>

<p>La idea detr√°s de esta t√©cnica es dar al usuario solo lo que necesita en un momento dado. Si abre una p√°gina en particular, solo necesita el c√≥digo de esa p√°gina, no toda la aplicaci√≥n.</p>

<p>Pero con el enfoque tradicional, le enviamos un gran paquete de JavaScript que luego debe ser analizado y ejecutado por el navegador, aunque el usuario final usar√° de manera realista solo una fracci√≥n de ese c√≥digo cuando abra la aplicaci√≥n.</p>

<p>Al usar paquetes m√°s peque√±os, podemos actuar de manera m√°s perezosa y enviar solo lo m√≠nimo para asegurarnos de que el usuario obtenga una experiencia positiva y no se distraiga pensando si ha apagado el horno. Una vez que est√© comprometido con la aplicaci√≥n, podemos precargar otros paquetes en segundo plano.</p>

<p>Lazy loading es una t√©cnica de optimizaci√≥n que carga solo los recursos (ima«µenes, <em>scripts</em>, etc.) que realmente se necesitan. En lugar de cargar una p√°gina web entera y renderizarla en el navegador todo de una vez, solo renderiza los componente cr√≠ticos primero y luego aquellos componentes restantes o cuando se vayan requiriendo.</p>

<p>React provee dos elementos para implementar <em>lazy loading</em>:</p>

<ul>
  <li>React.lazy() - React.lazy() es la funci√≥n que permite implementar la importaci√≥n din√°mica para componentes regulares en React.</li>
  <li>React.Suspense - React.suspense tiene una propiedad <em>fallback</em> que toma el elemento react que quiere renderizar mientras el componente se carga usando React.lazy</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">React</span><span class="p">,</span> <span class="p">{</span> <span class="nx">Suspense</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react</span><span class="dl">'</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">LazyComponent</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">lazy</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="k">import</span><span class="p">(</span><span class="dl">'</span><span class="s1">./LazyComponent</span><span class="dl">'</span><span class="p">));</span>

<span class="kd">function</span> <span class="nx">MyComponent</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
  <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="nx">Suspense</span> <span class="nx">fallback</span><span class="o">=</span><span class="p">{</span><span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="nx">Loading</span><span class="p">....</span><span class="o">&lt;</span><span class="sr">/div&gt;}</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="nx">LazyComponent</span> <span class="o">/&gt;</span>
    <span class="o">&lt;</span><span class="sr">/Suspense</span><span class="err">&gt;
</span>  <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span> <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>https://ichi.pro/es/optimizacion-de-las-aplicaciones-react-con-componentes-de-funcion-react-memo-usememo-lists-keys-76395047615674</p>

<p>https://alihacks.com/react-detras-de-escena-y-tecnicas-de-optimizacion-usememo-usecallback-react-memo/</p>

<p>https://platzi.com/clases/2118-react-hooks/34007-optimizacion-de-componentes-en-react-con-reactmemo/</p>

<h1 id="use-functionalstateless-components"><a href="#header-1"></a>Use Functional/Stateless Components</h1>

<p>The functional component prevents the construction of the class instance. It reduces the overall bundle size better than classes.</p>

<h1 id="binding-the-functions-in-early"><a href="#header-1"></a>Binding the Functions in Early</h1>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Bind the functions with elements in the render function will cause the performance issue. Because render() function to create a new function on every render.
If the arrow function is used inside the render() function, then each time browser executes an arrow function ("=&gt;") statement and it create a new function object. This can be an expensive operation depends on the situation.
If you are using the arrow function as props then it will break the performance optimizations such as shouldComponentUpdate and PureComponent.
</code></pre></div></div>

<h1 id="virtualizing-the-long-lists"><a href="#header-1"></a>Virtualizing the long lists</h1>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>If you want to render a large list of data, then just render the smaller portion of the list at a time (limited to viewport of the component) and render the remaining data whenever scrolled. This is called "windowing".
It will reduce the re-rendering time and avoid the number of DOM nodes to be created. 
</code></pre></div></div>

<p>https://reactjs.org/docs/optimizing-performance.html</p>

<h1 id="throttling-and-debouncing"><a href="#header-1"></a>Throttling and Debouncing</h1>

<p>Throttling and Debouncing are important optimization concepts to avoid multiple API calls.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Throttling
Throttling means executing the function at regular intervals, which means once the function is executed, it will start again only after a specified amount of time is over.
 
Debouncing
Debouncing means the function will execute when a user hasn't carried out an event in a specified amount of time.
</code></pre></div></div>

<h1 id="the-power-of-not-mutating-data"><a href="#header-1"></a>The Power Of Not Mutating Data</h1>

<p>https://reactjs.org/docs/optimizing-performance.html</p>

<h1 id="avoid-implying-inline-style-attribute"><a href="#header-1"></a>Avoid Implying Inline Style Attribute</h1>

<h1 id="dependency-optimization"><a href="#header-1"></a>Dependency Optimization</h1>

<h1 id="reactjs-developer-can-use-multiple-chunk-files"><a href="#header-1"></a>ReactJS developer can use multiple Chunk Files</h1>

<h1 id="bundle-analitic"><a href="#header-1"></a>Bundle Analitic</h1>

<p>medir con react-addons-perf p</p>

<p>https://medium.com/swlh/9-performance-optimization-strategies-for-reactjs-development-36f6d03a0912</p>

<p>https://www.toptal.com/react/componentes-react-eficientes-una-guia-para-optimizar-el-desempeno-de-react</p>

<p>https://latteandcode.medium.com/react-hooks-para-optimizar-el-rendimiento-7e4e5ec4894</p>

<p>https://ichi.pro/es/22-tecnicas-de-optimizacion-del-rendimiento-de-react-230208723231561</p>

<p>https://ichi.pro/es/tecnicas-de-optimizacion-del-rendimiento-en-react-123769334290435</p>

<p>https://ourcodeworld.co/articulos/leer/934/top-9-las-mejores-tecnicas-de-optimizacion-para-aplicaciones-react</p>
:ET